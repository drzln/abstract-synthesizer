# Abstract Synthesizer Overview

The `abstract-synthesizer` gem provides a Ruby DSL (Domain Specific Language) for defining hierarchical, resource-based configurations. It allows users to create structured data (manifests) using a declarative syntax, similar to how configuration files are often written.

## Core Concepts

- **Synthesizer**: The main component responsible for processing the DSL and building the manifest. It dynamically handles method calls to interpret resource definitions and field assignments.
- **Manifest**: The resulting hierarchical data structure (a Ruby Hash) generated by the synthesizer, representing the defined configuration.
- **Keys**: A predefined set of allowed methods that the synthesizer recognizes as valid resource or field names within the DSL.
- **Bury**: A utility module that extends the `Hash` class, enabling nested assignment of values, which is fundamental for building the hierarchical manifest.

## Architecture Diagram

```mermaid
graph TD
    A[User DSL Input] --> B{AbstractSynthesizer};
    B -- "method_missing calls" --> C[abstract_method_missing];
    C -- "Validates method/args" --> D{Validation Logic};
    D -- "Raises Errors" --> E[Custom Errors];
    C -- "Builds nested hash" --> F[Bury Module (extends Hash)];
    F --> G[Manifest (Ruby Hash)];
    B -- "Returns" --> G;

    subgraph SynthesizerFactory
        H[create_synthesizer] --> B;
    end
```

## How it Works

1.  **Initialization**: A `Synthesizer` instance is created, optionally via the `SynthesizerFactory`, which injects the allowed `keys` for the DSL.
2.  **DSL Evaluation**: The `synthesize` method evaluates a Ruby block or string. Inside this context, method calls are intercepted.
3.  **Dynamic Method Handling**: The `method_missing` method (overridden in `AbstractSynthesizer` or dynamically defined by `SynthesizerFactory`) delegates to `abstract_method_missing`.
4.  **Validation**: `abstract_method_missing` validates the called method against the allowed `keys` and checks argument counts.
5.  **Manifest Building**: Based on the method and arguments, the synthesizer uses the `bury` method (provided by the `Bury` module) to insert data into the `translation[:manifest]` hash, creating nested structures as needed.
6.  **Result**: The final `manifest` hash represents the structured configuration defined by the DSL.
